---- Conditions Guide ----

Conditions are rules that can be evaluated against different types of entities (cells, groups, factions, etc). These return a boolean value of 'true' when the condition is meet. Otherwise return false. When chained together on a requirement list of comma separated conditions (e.g. '<condition1>','<condition2>'), all of them must be true for the requirement to pass. By default, conditions are evaluated against the base target unless a special operator is specified. For example, group conditions are evaluated by default against the target group unless an operator like [ANY_NEIGHBOR] is prefixed. In which case the condition will be evaluated against the neighbor groups of the target group.

- General condition operators -

[NOT] : A condition can be negated by prefixing [NOT] before the condition. A negated condition must be false to pass. Both the prefix and the condition must be enclosed together in quotes like this: '[NOT]<condition>'

[AND] : Two or more conditions can be evaluated together using the [AND] infix. In which case, all of the conditions within the conjunction must be true for the statement to pass. All of the conditions and infixes in the statement must be enclosed together in quotes like this: '<condition1>[AND]<condition2>([AND]<additional conditions>)'

[OR] : Two or more conditions can be evaluated together using the [OR] infix. In which case, if any of the conditions within the disjunction is true then the whole statement passes. All of the conditions and infixes in the statement must be enclosed together in quotes like this: '<condition1>[OR]<condition2>([OR]<additional conditions>)'

- Group condition operators -

[ANY_N_GROUP] : The target condition must be true for at least one neighbor cell group. The condition to be evaluated with this operator must be applicable to cell groups. Both the prefix and the condition must be enclosed together in quotes like this: '[ANY_N_GROUP]<condition>'

[ALL_N_GROUPS] : The target condition must be true for all neighbor cell groups. The condition to be evaluated with this operator must be applicable to cell groups. Both the prefix and the condition must be enclosed together in quotes like this: '[ALL_N_GROUPS]<condition>'

[AT_LEAST_N_GROUPS:<count>] : The target condition must be true for at least <count> cell groups. The condition to be evaluated with this operator must be applicable to cell groups. Both the prefix and the condition must be enclosed together in quotes like this: '[ALL_N_GROUPS]<condition>'

- Cell condition operators -

[ANY_N_CELL] : The target condition must be true for at least one neighbor terrain cell. The condition to be evaluated with this operator must be applicable to terrain cells. Both the prefix and the condition must be enclosed together in quotes like this: '[ANY_N_CELL]<condition>'

[ALL_N_CELLS] : The target condition must be true for all neighbor terrain cells. The condition to be evaluated with this operator must be applicable to terrain cells. Both the prefix and the condition must be enclosed together in quotes like this: '[ALL_N_CELLS]<condition>'

[AT_LEAST_N_CELLS:<count>] : The target condition must be true for at least <count> terrain cells. The condition to be evaluated with this operator must be applicable to terrain cells. Both the prefix and the condition must be enclosed together in quotes like this: '[ALL_N_GROUPS]<condition>'


Operators can be uses together using parenthesis to set modifier priority (values between parenthesis evaluate first).
Example: '[NOT](<condition1>[OR]([ANY_N_GROUP]<condition2>)[OR]<condition3>)'

---

Here's a list of the current types of conditions (more to be added in future versions) and how they work:

- 'group_has_knowledge'
    Tests if a group currently possesses a particular knowledge identified by id, and the knowledge level is equal or greater than the specified value (optional integer value between 0 and 10000). The format of the constraint is as follows: 'group_has_knowledge:<knowledge_id>(,<level>)'

    Examples: 'group_has_knowledge:agriculture_knowledge', 'group_has_knowledge:shipbuilding_knowledge,3'

- 'group_population'
    Tests if a group currently possesses at least certain amount of population. The value can be any quantity between 1 and 2,147,483,647. The format of the constraint is as follows: 'group_min_population:<quantity>'

    Examples: 'group_min_population:10000'

- 'cell_has_sea'
    Tests if a cell has a sea presence equal or greater than 0.01 or than the specified value (optional value between 0 and 1. See note 1). The format of the constraint is as follows: 'cell_has_sea(:<min_presence>)'

    Examples: 'cell_has_sea', 'cell_has_sea:0.5'

- 'cell_accessibility'
    Tests if a cell has an accessibility value (i.e. how accessible the terrain is) equal or greater than 0.01 or than the specified value (optional value between 0 and 1). The format of the constraint is as follows: 'cell_accessibility(:<min_accessibility>)'

    Examples: 'cell_accessibility', 'cell_accessibility:0.2'

- 'cell_arability'
    Tests if a cell has an arability value (i.e. how arable the land is) equal or greater than 0.01 or than the specified value (optional value between 0 and 1). The format of the constraint is as follows: 'cell_arability(:<min_arability>)'

    Examples: 'cell_arability', 'cell_arability:0.6'

- 'cell_hilliness'
    Tests if a cell has an hilliness value (i.e. how hilly the terrain is) equal or greater than 0.01 or than the specified value (optional value between 0 and 1). The format of the constraint is as follows: 'cell_hilliness(:<min_hilliness>)'

    Examples: 'cell_hilliness', 'cell_hilliness:0.4'

- 'cell_wood_coverage'
    Tests if a cell has a wood coverage (i.e. the total amount of biome presence on a cell with the 'wood' trait) equal or greater than 0.01 or than the specified value (optional value between 0 and 1). The format of the constraint is as follows: 'cell_wood_coverage(:<min_wood_coverage>)'

    Examples: 'cell_wood_coverage', 'cell_wood_coverage:0.4'


NOTES:
1.  The parameter has a precision limit of two decimal places (eg. 0.01 is the smallest value possible above 0, and 0.99 the largest possible below 1)

--
