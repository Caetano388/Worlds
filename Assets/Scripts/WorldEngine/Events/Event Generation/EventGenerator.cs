using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Xml;
using System.Xml.Serialization;

/// <summary>
/// Object that generates events of a certain type during the simulation run
/// </summary>
public abstract class EventGenerator : Context
{
    public const string FactionTargetType = "faction";
    public const string GroupTargetType = "group";

    /// <summary>
    /// Global UId counter
    /// </summary>
    public static long CurrentUId = StartUId;

    /// <summary>
    /// The UId to use for events generated by this generator
    /// </summary>
    public long UId;

    /// <summary>
    /// String Id for the events
    /// </summary>
    public string Id;
    /// <summary>
    /// Name to use in the UI for the events
    /// </summary>
    public string Name;

    /// <summary>
    /// Hash to use for RNGs that use events of this type
    /// </summary>
    public int IdHash;

    /// <summary>
    /// Conditions that decide if an event should be assigned to a target
    /// </summary>
    public IBooleanExpression[] AssignmentConditions;
    /// <summary>
    /// Conditions that decide if an event should trigger
    /// </summary>
    public IBooleanExpression[] TriggerConditions;

    /// <summary>
    /// Maximum time to pass before event triggers (since assignment date)
    /// </summary>
    public INumericExpression TimeToTrigger;

    /// <summary>
    /// Effects to occur after an event triggers
    /// </summary>
    public IEffectExpression[] Effects;

    /// <summary>
    /// First UId to use for events loaded from mods
    /// </summary>
    protected const long StartUId = WorldEvent.PlantCultivationDiscoveryEventId + 1;

    public static EventGenerator BuildGenerator(string targetStr)
    {
        switch (targetStr)
        {
            case FactionTargetType:
                return new FactionEventGenerator(targetStr);
            case GroupTargetType:
                return new GroupEventGenerator(targetStr);
        }

        throw new System.ArgumentException("Invalid target type: " + targetStr);
    }

    public bool CanAssignEventToTarget()
    {
        foreach (IBooleanExpression exp in AssignmentConditions)
        {
            if (!exp.Value)
                return false;
        }

        return true;
    }

    public bool CanTriggerEvent()
    {
        foreach (IBooleanExpression exp in TriggerConditions)
        {
            if (!exp.Value)
                return false;
        }

        return true;
    }

    public long CalculateEventTriggerDate(World world)
    {
        float randomFactor = GetNextRandomFloat(IdHash);

        float timeToTrigger = TimeToTrigger.Value;

        float dateSpan = randomFactor * timeToTrigger;

        long targetDate = world.CurrentDate + (long)dateSpan + 1;

        if ((targetDate <= world.CurrentDate) || (targetDate > World.MaxSupportedDate))
        {
            // log details about invalid date
            Debug.LogWarning("Discovery+Event.CalculateTriggerDate - targetDate (" + targetDate +
                ") less than or equal to world.CurrentDate (" + world.CurrentDate +
                "), randomFactor: " + randomFactor +
                ", timeToTrigger: " + timeToTrigger +
                ", dateSpan: " + dateSpan);

            return long.MinValue;
        }

        return targetDate;
    }

    public void TriggerEvent()
    {
        foreach (IEffectExpression exp in Effects)
        {
            exp.Apply();
        }
    }

    public abstract ModEvent GenerateEvent(long triggerDate);
    public abstract long GenerateUniqueIdentifier(long triggerDate);

    protected abstract float GetNextRandomFloat(int seed);
}
